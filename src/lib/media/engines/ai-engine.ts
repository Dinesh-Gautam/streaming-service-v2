import * as fs from 'fs';
import * as path from 'path';

// Genkit Core and Google AI Plugin
// Assume genkit is configured globally, e.g., in genkit.config.ts

// Import base class and types
import { z } from 'zod'; // Using Zod for parsing the structured output

import {
  AiResponseSchema,
  AnalyzeSubtitlesFlow,
  GenerateMovieImagesFlow,
} from '@/lib/ai/flow';

import { AIEngineOutput, SubtitleOutput } from '../engine-outputs';
import { EngineOutput, MediaEngine } from '../media-engine';

// Interface for options passed to the AI Engine's process method
interface AIEngineProcessOptions {
  subtitleOutput?: SubtitleOutput;
}

type AiResponseType = z.infer<typeof AiResponseSchema>;

// Specify the output type for this engine
export class AIEngine extends MediaEngine<AIEngineOutput> {
  constructor() {
    super('AIEngine');
    // Constructor remains minimal, API key checked in process
  }

  async process(
    inputFile: string,
    outputDir: string,
    options?: AIEngineProcessOptions,
  ): Promise<EngineOutput<AIEngineOutput>> {
    this.updateStatus('running');
    this._progress = 0;
    this._errorMessage = null;

    console.log(
      `[${this.engineName}] Starting AI processing for: ${inputFile}`,
    );

    // --- Check API Key & Initialize Genkit Instance ---
    const googleApiKey = process.env.GOOGLE_API_KEY;
    if (!googleApiKey) {
      const errorMsg = 'GOOGLE_API_KEY environment variable not set.';
      console.error(`[${this.engineName}] ${errorMsg}`);
      this.fail(errorMsg);
      return { success: false, error: errorMsg };
    }

    // --- Input Validation ---
    const subtitleOutput = options?.subtitleOutput;
    if (
      !subtitleOutput?.paths?.vtt ||
      Object.keys(subtitleOutput.paths.vtt).length === 0
    ) {
      const errorMsg = 'Missing subtitle VTT file paths in input options.';
      console.error(`[${this.engineName}] ${errorMsg}`);
      this.fail(errorMsg);
      return { success: false, error: errorMsg };
    }

    const vttPaths = subtitleOutput.paths.vtt;
    const sourceLangCode = Object.keys(vttPaths)[0];
    const sourceVttPath = vttPaths[sourceLangCode];

    if (!sourceVttPath || !fs.existsSync(sourceVttPath)) {
      const errorMsg = `Source VTT file not found at path: ${sourceVttPath}`;
      console.error(`[${this.engineName}] ${errorMsg}`);
      this.fail(errorMsg);
      return { success: false, error: errorMsg };
    }

    // Extract movieId from outputDir (assuming outputDir path ends with the ID)
    const movieId = path.basename(outputDir);
    if (!movieId) {
      const errorMsg = `Could not determine movieId from outputDir: ${outputDir}`;
      console.error(`[${this.engineName}] ${errorMsg}`);
      this.fail(errorMsg);
      return { success: false, error: errorMsg };
    }
    console.log(`[${this.engineName}] Using movieId: ${movieId}`);

    try {
      // --- Read VTT Content ---
      console.log(
        `[${this.engineName}] Reading VTT content from: ${sourceVttPath}`,
      );
      let vttContent = await fs.promises.readFile(sourceVttPath, 'utf-8');
      this.updateProgress({ percent: 10 });

      // --- Basic VTT Cleaning (Optional but recommended) ---
      // Remove VTT header and empty lines to reduce token count
      vttContent = vttContent
        .replace(/^WEBVTT\s*/, '')
        .replace(/^\s*[\r\n]/gm, '');
      // Consider further cleaning/chunking if VTT is very large

      // --- Call Genkit Generate for Text Analysis ---
      console.log(
        `[${this.engineName}] Sending subtitle analysis request to Gemini...`,
      );
      this.updateProgress({ percent: 15 });

      const analysisResult = await AnalyzeSubtitlesFlow({ vttContent });
      this.updateProgress({ percent: 40 });

      if (!analysisResult.text) {
        throw new Error('AI subtitle analysis returned empty or invalid data.');
      }

      const aiData = JSON.parse(analysisResult.text) as AiResponseType;
      console.log(
        `[${this.engineName}] Received and parsed AI text analysis response.`,
      );

      // --- Construct Chapters VTT (if generated) ---
      const chaptersVttContent =
        aiData.chaptersVtt ?
          this._constructChapters(aiData.chaptersVtt)
        : undefined;

      if (chaptersVttContent) {
        const chaptersVttPath = path.join(
          outputDir,
          `${path.parse(inputFile).name}.chapters.vtt`,
        );
        try {
          await fs.promises.writeFile(chaptersVttPath, chaptersVttContent);
          console.log(
            `[${this.engineName}] Chapters VTT saved to: ${chaptersVttPath}`,
          );
        } catch (writeError: any) {
          console.warn(
            `[${this.engineName}] Failed to save chapters VTT file: ${writeError.message}`,
          );
        }
      } else {
        console.log(`[${this.engineName}] No chapter VTT generated by AI.`);
      }
      this.updateProgress({ percent: 50 });

      // === Step 2: Generate Images (if text analysis succeeded) ===
      let posterImagePath: string | undefined = undefined;
      let backdropImagePath: string | undefined = undefined;

      if (aiData.title && aiData.description && aiData.genres) {
        console.log(`[${this.engineName}] Starting AI image generation...`);
        try {
          const imageResult = await GenerateMovieImagesFlow({
            movieId: movieId,
            title: aiData.title,
            description: aiData.description,
            genres: aiData.genres,
          });
          posterImagePath = imageResult.posterImagePath;
          backdropImagePath = imageResult.backdropImagePath;
          console.log(`[${this.engineName}] AI image generation completed.`);
          this.updateProgress({ percent: 90 });
        } catch (imageError: any) {
          console.warn(
            `[${this.engineName}] AI image generation failed: ${imageError.message}`,
            imageError,
          );
          this.updateProgress({ percent: 90 });
        }
      } else {
        console.warn(
          `[${this.engineName}] Skipping image generation due to missing title, description, or genres from text analysis.`,
        );
        this.updateProgress({ percent: 90 });
      }

      // === Step 3: Construct Final Output ===
      const outputData: AIEngineOutput['data'] = {
        title: aiData.title,
        description: aiData.description,
        genres: aiData.genres,
        keywords: aiData.keywords,
        suggestedAgeRating: aiData.suggestedAgeRating,
        contentWarnings: aiData.contentWarnings,
        chapters:
          chaptersVttContent ? { vttContent: chaptersVttContent } : undefined,
        posterImagePath: posterImagePath,
        backdropImagePath: backdropImagePath,
      };

      this.updateProgress({ percent: 100 });
      console.log(`[${this.engineName}] AI processing completed successfully.`);
      this.complete();
      return {
        success: true,
        output: {
          data: outputData,
        },
      };
    } catch (error: any) {
      let errorMessage = 'An unexpected error occurred during AI processing.';
      if (error instanceof Error) {
        errorMessage = error.message;
      } else if (typeof error === 'string') {
        errorMessage = error;
      }
      // Log the full error for debugging
      console.error(
        `[${this.engineName}] Error during AI processing:`,
        errorMessage,
        error,
      );
      this.fail(errorMessage);
      return { success: false, error: errorMessage };
    }
  }

  private _constructChapters(
    chaptersVtt: NonNullable<AiResponseType['chaptersVtt']>,
  ): string {
    const vttContent = chaptersVtt.map((chapter, index) => {
      return `${this._formatVttTime(chapter.startTime)} --> ${chaptersVtt[index + 1] ? this._formatVttTime(chaptersVtt[index + 1].startTime - 1) : 'end'}\n${chapter.chapterTitle}\n\n`;
    });

    vttContent.unshift('WEBVTT\n\n');

    return vttContent.join('');
  }

  private _formatVttTime(seconds: number): string {
    const date = new Date(0);
    date.setSeconds(seconds);
    const hours = date.getUTCHours().toString().padStart(2, '0');
    const minutes = date.getUTCMinutes().toString().padStart(2, '0');
    const secs = date.getUTCSeconds().toString().padStart(2, '0');
    const ms = date.getUTCMilliseconds().toString().padStart(3, '0');
    return `${hours}:${minutes}:${secs}.${ms}`;
  }
}
